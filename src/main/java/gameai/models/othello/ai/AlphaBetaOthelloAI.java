package gameai.models.othello.ai;

import gameai.models.IllegalMoveException;
import gameai.models.Position;
import gameai.models.othello.OthelloBoard;
import gameai.models.othello.OthelloColor;
import gameai.models.othello.OthelloPiece;

import java.util.List;

import static java.lang.Math.max;
import static java.lang.Math.min;

/**
 * This class is an implementation of the minimax algorithm for the game Othello / Reversi.
 */
public class AlphaBetaOthelloAI extends OthelloAI {
    private OthelloColor opponentColor;
    private int depth;

    /**
     * @param board the board to evaluate and calculate a move for.
     * @param playerColor
     * @param depth
     */
    public AlphaBetaOthelloAI(OthelloBoard board, OthelloColor playerColor, int depth) {
        super(board, playerColor);

        this.depth = depth;
    }

    /**
     * @return calculated move
     */
    @Override
    public Position calculateMove() {
        return alphabetaDecision(this.depth);
    }

    /**
     * This method uses the minimax algorithm with alpha-beta pruning to calculate a weight for the current node (board).
     *
     * @param board the current node in the decision tree.
     * @param depth the maximum search depth.
     * @param alpha
     * @param beta
     * @param maximizingPlayer
     * @return node weight
     */
    private int alphabeta(OthelloBoard board, int depth, int alpha, int beta, boolean maximizingPlayer) {
        List<Position> legalMoves = null;
        int value;

        if (depth == 0 || board.isGameOver()) {
            return heuristic(board);
        }

        legalMoves = board.getLegalMoves(board.getCurrentTurnColor());

        if (maximizingPlayer) {
            value = Integer.MIN_VALUE;

            for (Position move : legalMoves) {
                OthelloBoard temp = evaluate(board, move);

                if (temp == null) continue;

                value = max(value, alphabeta(temp, depth - 1, alpha, beta, false));
                alpha = max(alpha, value);


                if (alpha >= beta)
                    break;
            }

            return value;
        } else {
            value = Integer.MAX_VALUE;

            for (Position move : legalMoves) {
                OthelloBoard temp = evaluate(board, move);

                if (temp == null) continue;

                value = min(value, alphabeta(temp, depth - 1, alpha, beta, true));
                beta = min(beta, value);

                if (alpha >= beta)
                    break;
            }

            return value;
        }
    }

    /**
     * This method decides which move to make.
     *
     * @param depth the maximum search depth.
     * @return the best position generated by the minimax algorithm.
     */
    private Position alphabetaDecision(int depth) {
        List<Position> legalMoves = this.board.getLegalMoves(playerColor);

        int bestScore = Integer.MIN_VALUE;
        Position result = null;

        for (Position move : legalMoves) {
            OthelloBoard temp = evaluate(this.board, move);

            int score = alphabeta(temp, depth, Integer.MIN_VALUE, Integer.MAX_VALUE, false);

            if (score >= bestScore) {
                bestScore = score;
                result = move;
            }
        }

        return result;
    }

    /**
     * This method calculates the heuristic value of the current node.
     *
     * The heuristic is based on the following paper:
     * https://courses.cs.washington.edu/courses/cse573/04au/Project/mini1/RUSSIA/Final_Paper.pdf
     *
     * @param board the current node in the decision tree.
     * @return the heuristic value of the current node in the decision tree.
     */
    private int heuristic(OthelloBoard board) {
        int score = 0;

        // coin parity
        score += getCoinParity(board);

        // mobility value
        score += getMobilityValue(board);

        // utility value
        score += getUtilityValueForColor(board, playerColor) - getUtilityValueForColor(board, opponentColor);

        return score;
    }

    /**
     * @param board the current node in the decision tree.
     * @return the coin parity for the current node.
     */
    private int getCoinParity(OthelloBoard board) {
        int maximizingPlayerScore = board.getPlayerScore(playerColor);
        int minimizingPlayerScore = board.getPlayerScore(opponentColor);

        if(maximizingPlayerScore + minimizingPlayerScore == 0) return 0;

        return 100 * (maximizingPlayerScore - minimizingPlayerScore) / (maximizingPlayerScore + minimizingPlayerScore);
    }

    /**
     * @param board the current node in the decision tree.
     * @param color the color to search for.
     * @return the color's utility value.
     */
    private int getUtilityValueForColor(OthelloBoard board, OthelloColor color) {
        Position[][] positions = board.getPositions();
        int result = 0;

        int[][] weights = {
                {4, -3, 2, 2, 2, 2, -3, 4},
                {-3, -4, -1, -1, -1, -1, -4, -3},
                {2, -1, 1, 0, 0, 1, -1, 2},
                {2, -1, 0, 1, 1, 0, -1, 2},
                {2, -1, 0, 1, 1, 0, -1, 2},
                {2, -1, 1, 0, 0, 1, -1, 2},
                {-3, -4, -1, -1, -1, -1, -4, -3},
                {4, -3, 2, 2, 2, 2, -3, 4}
        };

        for(int row = 0; row < positions.length; row++) {
            for(int column = 0; column < positions[row].length; column++) {
                OthelloPiece piece = (OthelloPiece)positions[column][row].getPiece();

                if(piece == null) continue;

                if(piece.getColor() == color) {
                    result += weights[row][column];
                }
            }
        }

        return result;
    }

    /**
     * @param board the current node in the decision tree.
     * @param color the color to search for.
     * @return the mobility value of the color.
     */
    private int getMobilityValueForColor(OthelloBoard board, OthelloColor color) {
        return board.getLegalMoves(color).size();
    }

    /**
     * @param board the current node in the decision tree.
     * @return the mobility value for the current node.
     */
    private int getMobilityValue(OthelloBoard board) {
        int maximizingPlayerScore = getMobilityValueForColor(board, playerColor);
        int minimizingPlayerScore = getMobilityValueForColor(board, opponentColor);

        if(maximizingPlayerScore + minimizingPlayerScore == 0) return 0;

        return 100 * (maximizingPlayerScore - minimizingPlayerScore) / (maximizingPlayerScore + minimizingPlayerScore);
    }

    /**
     * @param original the original board.
     * @param position the position to evaluate.
     * @return a new board with the evaluated position.
     */
    private OthelloBoard evaluate(OthelloBoard original, Position position) {
        OthelloBoard board = new OthelloBoard(original);
        position = board.getPositions()[position.getY()][position.getX()];

        try {
            board.setPieceAtPosition(new OthelloPiece(board.getCurrentTurnColor()), position);
        } catch (IllegalMoveException e) {
            e.printStackTrace();

            return null;
        }

        return board;
    }
}